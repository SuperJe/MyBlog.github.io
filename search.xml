<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021-新年快乐</title>
    <url>/2021/01/01/2021-%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/</url>
    <content><![CDATA[<h1 id="“特别的”2020"><a href="#“特别的”2020" class="headerlink" title="“特别的”2020"></a>“特别的”2020</h1><p>2020是注定被历史所铭记的一年。</p>
<a id="more"></a>

<h2 id="春"><a href="#春" class="headerlink" title="春"></a>春</h2><p>1月一开始就自己作死。<br>1月21号回到厦门, 见了一个<strong>特别</strong>的人。<br>1月22号回到仙游, 我也过了一个<strong>特别</strong>的春节, 经历了一些<strong>特别</strong>的事。<br>春节期间, 和林霁、陈相天天搓麻将, 逃避现实。随后就进入了音频化项目的加班模式，更利于我的逃避模式。</p>
<p>因为疫情, 然后<strong>七七八八</strong>的事情，直到3月份我才回到深圳去搬砖。也是搬砖的第一周, 想明白了一些事情, 最后也得到了很多遗憾。</p>
<p><strong>只觉得十分遗憾。脑子也开始间歇性抽疯, 所以我到底是特别还是七七八八？</strong></p>
<h2 id="夏"><a href="#夏" class="headerlink" title="夏"></a>夏</h2><p>大体已经不记得这个夏天发生了什么, 这是第一个没有给我带来深刻印象的夏天，夏天真的走了。<br>疫情的持续, 团建的推迟, 大批新人入职, 996的结束, 我辗转了3个组。同时, Gavin作为我们的负责人, 在Core里的三进三出…</p>
<p>中规中矩, 没有目标。打了一个不好不坏的绩效, 升了一级, 符合我的预期, 但精神状态就很差了。忙碌于业务之中, 没有写过让自己开心的代码, 没有owner意识, 更不想为我所厌弃的人去卖命, 去抛头颅洒热血。 我或许永远不会成为一名将军, 无法带领兵马, 但我可以是一名优秀的冲锋兵, 我不怕打仗不怕熬, 只是我不想跟着一个昏庸无能的将军打仗。</p>
<p>我向他提出了要转组, 当然, 结局也是意料之内的以后再说。</p>
<h2 id="秋"><a href="#秋" class="headerlink" title="秋"></a>秋</h2><p>算是符合收获的季节吧。<br>秋天, 认识了小黄鸭。有争吵有欢笑, 还需要磨合的更好, 这是我拥有的最好了。<br>体重也控制了二十多斤。</p>
<h2 id="冬"><a href="#冬" class="headerlink" title="冬"></a>冬</h2><p>今年的深圳还算入冬成功了, 好几次的寒潮, 比去年早得很。<br>同时, DW也来了。</p>
<p>除了导师之外, 还要感谢DW。虽然刚来成为我的leader, 但是从里到外我都是respect的。DW是我愿意抛头颅洒热血的将军, 也是让我有了owner意识的人，一切规划开始井井有条起来, 路子宽阔了, 代码也开始会跳动了。原本打算年后离职, 去见一见外面的世界, 去找到写代码的快乐。现在，我开始期待DW接下来带领我们的一年了。</p>
<h2 id="结"><a href="#结" class="headerlink" title="结"></a>结</h2><p>我的2020用这种语调来阐述有点沉重, 但2020是确实是我短暂的人生中又一次的滑铁卢。</p>
<p><strong>I screwed it up, again.</strong></p>
<p>初中的思想政治课就在教我们要正确认识自己, 要改正, 这一年的一开始, 我又狗改不了吃屎了。正如同小时候看作文, 始终不里脊肉为什么大家要说世界上没有后悔药, 又有什么好后悔的呢？ 现在我可想要这样的东西了。</p>
<p><strong>整个2020, 大部分时间我都做错了, 无论是生活还是工作。</strong></p>
<h1 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h1><p>还是像往常一样, 希望2021自己真的能变好, 希望生活也能变好, 不想再有遗憾了。</p>
<p>最后, flag时间:</p>
<ul>
<li>看4本技术书籍！</li>
<li>走上绿色通道去升级！</li>
<li>坚持定投！</li>
<li>体重控制到64KG！</li>
<li>2022争取拿到32K的offer！</li>
<li>2022的新年快乐要以快乐的调调来写！</li>
</ul>
<p>新年快乐, 加油🎉🎉🎉</p>
]]></content>
      <categories>
        <category>发疯随笔</category>
      </categories>
      <tags>
        <tag>精神病发作</tag>
      </tags>
  </entry>
  <entry>
    <title>Manacher</title>
    <url>/2021/02/12/Manacher-md/</url>
    <content><![CDATA[<p>感谢此篇博文的讲解。<a href="https://wmathor.com/index.php/archives/954/">https://wmathor.com/index.php/archives/954/</a></p>
<a id="more"></a>

<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>给一个字符串 str，要求用 O (n) 的时间复杂度求出其中最长回文子串</p>
<h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><h2 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h2><p>求最大回文子串的长度一般要看原串的长度是奇数还是偶数，然后分别求得。<br>但 Manacher 算法的第一个神奇之处就是把两种字符串都化为长度为奇数，从而简化计算:</p>
<pre><code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">genManacherStr</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">manacher</span><span class="params">(str.size() * <span class="number">2</span> + <span class="number">1</span>, <span class="string">&#x27;#&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; manacher.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &amp; <span class="number">1</span>)   manacher[i] = str[i/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; manacher &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> manacher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p><strong>也就是将每个字符的间隔间插入一个’#’字符(或其他不会出现的字符都可以)</strong> 。这样就将原字符串长度变成奇数, 并且使以每个原字符为中心的都是对称的。如原来是aba，变化之后就是 #a#b#a#，无论原来是奇数还是偶数，变化之后都是奇数，方便处理。</p>
<h2 id="三个重要概念"><a href="#三个重要概念" class="headerlink" title="三个重要概念"></a>三个重要概念</h2><ol>
<li>回文右边界下标R。</li>
<li>回文中心C。</li>
<li>记录每个字符的回文半径长度数组helper。</li>
</ol>
<h3 id="回文右边界下标R"><a href="#回文右边界下标R" class="headerlink" title="回文右边界下标R"></a>回文右边界下标R</h3><p>指的是当前构成回文半径时, 此回文字符串的最右边的下标索引。<br>如#a#b#a#, 当遍历到第一个’a’时, 下标索引是1， 回文右边界下标将达到’a’右侧的’#’, 下标R为2, 回文半径长度为(2-1)+1=2。</p>
<h3 id="回文中心C"><a href="#回文中心C" class="headerlink" title="回文中心C"></a>回文中心C</h3><p><strong>达到回文最右边界下标R时</strong>的对称中心C, 如上述例子的遍历到第一个’a’时的下标1, 就是当前的回文中心C。</p>
<h3 id="记录每个字符的回文半径数组helper"><a href="#记录每个字符的回文半径数组helper" class="headerlink" title="记录每个字符的回文半径数组helper"></a>记录每个字符的回文半径数组helper</h3><p>每个字符所对应的最大半径, 如上述例子的第一个’a’, 半径就是2。</p>
<h2 id="如何确定回文半径"><a href="#如何确定回文半径" class="headerlink" title="如何确定回文半径"></a>如何确定回文半径</h2><p><strong>首先, 我们需要初始化最右回文边界下标为-1, 回文中心的下标为-1。</strong></p>
<p>接着我们需要分2种大情况来讨论:</p>
<ul>
<li>当前判断的下标索引i大于等于回文右边界的下标R。</li>
<li>当前判断的下标索引i小于最右回文右边界的下标R。</li>
</ul>
<h3 id="情形一-i-gt-R"><a href="#情形一-i-gt-R" class="headerlink" title="情形一: i &gt;= R"></a>情形一: i &gt;= R</h3><p><img src="/2021/02/12/Manacher-md/manacher1.png" alt="情形一: i &gt;= R"></p>
<p>此时我们没法得知i的右边是否和i的左边构成回文字符串, 只能暴力扩展。<br><strong>(图中是i &gt; R下标的情况, 实际上从i == R的时候就开始要暴力扩展了)。</strong></p>
<h3 id="情形二-i-lt-R"><a href="#情形二-i-lt-R" class="headerlink" title="情形二: i &lt; R"></a>情形二: i &lt; R</h3><p>这是问题的关键, 假如我们已经求出了helper[0,1,2,…,i-1], 现在要求出i的回文半径。分以下三种情况:</p>
<h4 id="i的对称点i’的左边界超过了回文左边界"><a href="#i的对称点i’的左边界超过了回文左边界" class="headerlink" title="i的对称点i’的左边界超过了回文左边界"></a>i的对称点i’的左边界超过了回文左边界</h4><p>回文左边界就是回文右边界关于C的对称坐标，定义一样。如图:</p>
<p><img src="/2021/02/12/Manacher-md/manacher2.png" alt="i&#39;左边界超过了回文左边界"></p>
<p><strong>这个情况直接可以断定i的回文右边界和R重合。</strong> 证明如下:</p>
<ul>
<li>如图，i到R之间的字符串为S, 那么关于C对称，可以得到R’到i’之间的字符串为S’。</li>
<li>又因为R’到i’之间的S’关于i’对称, 所以可以得到对称的字符串S在i’的左侧处。</li>
<li>而i’左侧的S又关于C的对称，正好会落于i的左侧部分。所以i的回文半径字符串<strong>至少为S.</strong></li>
</ul>
<p><strong>上述证明了i的回文半径字符串为S, 那如何证明只能为S呢？</strong></p>
<p>已知i’的最左边界超过了R’，那么表示超过的部分不关于C的对称。<br>也就是说，i右侧的字符串S如果向外扩展，它与R’的左侧是不对称的。所以得证，只能为S。</p>
<h4 id="i的对称点i’的左边界小于R’"><a href="#i的对称点i’的左边界小于R’" class="headerlink" title="i的对称点i’的左边界小于R’"></a>i的对称点i’的左边界小于R’</h4><p><img src="/2021/02/12/Manacher-md/manacher3.png" alt="i&#39;左边界在回文左边界内"></p>
<p>还是用S字符串来证明。这种情况就比较简单。和上述证明方式一样，S不可能外扩，必将和i’的回文字符串一致，<strong>所以为helper[i’].</strong></p>
<h4 id="i的对称点i’的左边界正好和R’重合"><a href="#i的对称点i’的左边界正好和R’重合" class="headerlink" title="i的对称点i’的左边界正好和R’重合"></a>i的对称点i’的左边界正好和R’重合</h4><p><img src="/2021/02/12/Manacher-md/manacher4.png" alt="i&#39;左边界与R&#39;重合"></p>
<p>显而易见, 还是要暴力往外扩。</p>
<h3 id="两种情况下的部分代码建模"><a href="#两种情况下的部分代码建模" class="headerlink" title="两种情况下的部分代码建模"></a>两种情况下的部分代码建模</h3><p>综上分析，</p>
<ul>
<li>当i在R的右边界外时，回文半径应该初始化为1，然后去暴力扩展，左右相同时半径+1.</li>
<li>当i在R的右边界内时，看i’的左边界:<ul>
<li>情况a: i’左边界超出回文半径左边界，那么回文半径应该初始化为<strong>R-i</strong>, 即上述字符串S的长度。</li>
<li>情况b: i’左边界在回文半径左边界内, 那么回文半径应该初始化为helper[i’], i’下标为C-(i-C) = 2 * C - i, 所以为helper[2 * C - i]。</li>
<li>情况c: i’左边界与回文半径左边界重合, 那么回文半径应该初始化为helper[i’], 然后再暴力扩展。</li>
</ul>
</li>
</ul>
<p>所以当R &gt; i 时, 回文半径可以初始化为min(R-i, helper[2 * C - i]), 然后再去暴力扩展。<br>这么写的话，碰到情况a, 那么小的值就是R-i, 暴力扩展第一次就会发现不匹配。<br>碰到情况b, 小的值就是helper[i’], 暴力扩展第一次也会发现不匹配。<br>碰到情况c, helper[i’]和R-i是相等的，暴力扩展到第一次出现不匹配为止，当然，每成功匹配一次需要+1。</p>
<p>当i&gt;=R时，就应该初始化半径为1，再去暴力扩展。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.size() &lt; <span class="number">2</span>)    <span class="keyword">return</span> s;</span><br><span class="line">    <span class="built_in">string</span> manacher = genManacherStr(s);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">helper</span><span class="params">(manacher.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> R = <span class="number">-1</span>, C = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; manacher.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根据i是否在R里面来讨论</span></span><br><span class="line">        helper[i] = R &gt; i ? min(R-i, helper[<span class="number">2</span>*C-i]) : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i+helper[i] &lt; manacher.size() &amp;&amp; i-helper[i] &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(manacher[i+helper[i]] == manacher[i-helper[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                helper[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新回文最右边界的下标R和回文中心C</span></span><br><span class="line">        <span class="keyword">if</span>(i+helper[i] &gt; R)</span><br><span class="line">        &#123;</span><br><span class="line">            R = i + helper[i];</span><br><span class="line">            C = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若回文半径变长，需要算出原字符串的起始索引start</span></span><br><span class="line">        <span class="keyword">if</span>(helper[i] &gt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            len = helper[i];</span><br><span class="line">            <span class="comment">// 这一步真尼玛难算啊！先算出加了#的manacher字符串中，回文字符串的最左边界应该是i-(len-1) = i-len+1。</span></span><br><span class="line">            <span class="comment">// 如#a#b#a#, b为回文中心时, i为3, len的值为4，即最长回文半径的值为4，回文最左边界就是3-(4-1)=0.</span></span><br><span class="line">            <span class="comment">// 由于添加了#字符,所以回文串总以#为起始和结尾，所以i-len+1这个下标对应的一定是#.</span></span><br><span class="line">            <span class="comment">// 所以最左边#的右边一个字符，就是原字符串的回文最左侧, 即i-len+2;</span></span><br><span class="line">            <span class="comment">// 那么, 对应原字符串的下标为(i-len+2)/2, 可得start=(i-len+2)/2;</span></span><br><span class="line">            start = (i-len+<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长度为len-1，因为对称中心只有1个字符，不能算2遍。</span></span><br><span class="line">    <span class="comment">// 所以加了#的Manacher字符串的回文半径-1就等于原字符串的回文直径长度。</span></span><br><span class="line">    <span class="keyword">return</span> s.substr(start, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
</search>
