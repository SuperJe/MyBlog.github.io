<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021-新年快乐</title>
    <url>/2021/01/01/2021-%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="猜错了, 再来。" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="6950198c2d4746f26dd00d7bdfac45a567594a722124570553a868023b039fd3">87724cc9d114c3833ed77a08bf07d572f63d2a938bbd59b663da0f2bfc0e29e85c16832b80b14576e73837d15c276e5ad5182a07d79d033acd3b9317021d82e5320d9bf29f5f8c730c9ad377b29a5c477a9f4171846930b5cb3c71d2373663b921442588e18e6d0754e3850716915bdf19a9cc7e0917348008bd60deabd9453be0ea889bf8413d8076c792bbaa31e516f2fbfd12fe8e1ccfe97a07bd12874778ed6351d88a0cce77926a8db6ec677b3bff28e3919347576c6846e9a000fe4bb2cd356bdab1a4f85a5f80888ac82f9d69794ff9f6fe5912be59a1ee218895b4381b9a394e96d05e47a0c29edf6fc2476d12a633d97f03965fa0faf5dc4d075e9a72403c698f2a0c02068b147e85493d8fa41fece3166ebe810dbe27bb7ed4905335d102da055ad32d93ac42e400a929bccee52834f250c7e649dba1bcc2749d3f7e2f322325edc7ff9060b5db93c7649a5fd2ed4cc8560faf37934fbda4ef79296fb518323cd1710fea2af5dfe990f87389db86b7260c88e6e3245f6d06af9b81caf7b8513c45ea3c3219eb4320337890c00f3b92fcf80384d389d4a2f89125ffb21313a7876fdd168b6fb34e6e537bda285cb866c5b97e6f2302c1d3e802d65af2274a1226a78e31187041a72074c42856fbf4fc44cb1fe797f72d0ae6dee81a9b419a13f5ae008cbc1e84014a9d5cc425f4ab9289633ebc2308402e0e84006d16585e9e5c860f55d080b9fe21f3d0502a0eac084ec81cb24b4cc5ab79fb4f0f04aa382fbf92b91ce7d72fe61d9acef0857ce78e4694c8efaad1463c0da3de0364fcc1d3f7eed12bd5cc86f40709e791383ab83926bc64f7698fe7967c119ed93d5fcefe640a39b8d84f5b1b6285f6063d9787f34e56a8708e75565158d9684ca6c89b4af2726da00eb29b52f5530f450634ad11fe26b97d3f53dd89d1403fd4f82f901e6e8cc772997d8b7fb8a0a13d4e9118548a3750101d8672d3b9af808da8a1e8112c6ed624df2881c623fc0eec9fb376fb13e368ca7ae35e894821f187943013d1fe93480c58b24c00f075ee2bf5e19bf1d51eb9b2afa409889fa62f85e3c5540fa233971ab7235083b1c1b1cf9118e3de55c69b12e454c84ee31ce7c01d8fc9cc8c2018a3bc3ca46f68a64d48f132d9076d5c1b51f70fc6b578d6f593840ec0d2754c23448f2b51dde8e8ecf4302c85e2d61b6f2ce476d0804b036077372b519d421724dbbf3a54d6ce3039a1581133230b719a72af7e4eb0eff20e04d275dc5b22e6f439755d8da82e9b5d82c2ff886071722e782288588503424e9b6268f6c44e25f34e4a52fe94318b919f24b4678c660bb6f66658078ff0403252fa922cefc9094630ce18ad026c3b75ba99aef6c4dc06f79b8820655ad0f1eb4a447391d9e74abd0bb87f51485f75067c03004f0aba18f277d5b55e526ee992536065f4af9135aa34adc4886cd3c7dce3d870c84c1cf1c7e2dd93a40d8214f1e4ec9ec0cf6bd0529bf58dee3dd6f24eaa8e587ad47b23e91a487122fe869bcfbbe81894f485d9a0b7cc9cf12c8dbfe3b5ba5bbb6bc629623efdca939d311d4382d5040176bd3cd1835401f7e7641ad0fc72e9f600d87592421fe7ee9ae977f7980136ad1e1a13bcae6139be6faf6831254770a650280206c6955a137cfdffd1d40d0489e19ebada2ec1594c6cd1658e2295e15869248a6174df4d5bbc760f05ea0573879ba32b8b39653de6e522327769d82d8c192811a008363345cf365d66d82e6fb902d047e3f1cc6f4801184682f75d28f3a9feccd9d1aba94951ad4ed25a6ff615587c52beddbf418bacc0d71a472296271e3d266a4984ed096c6285ecebd3cc1edcab7c15e9c5eb6a4b216858be3b9c99b06de0bd39dda9d425a20513f8c2fc6381215f322379338b96fa26331a6f304870683016e4c075a198bcfd3a718bcf9fb85f9b0e8f305a9e8a066aae4d6618b60c8036a73e24fb3e8435bc72ed16de5fd2d9da5d8313a11da1abb617c2784e3391e0b7bb2833939cb516fe76cdb11e8c737638ac8e902d3049245146b0a491d9a0fe9240c6147fbc07e901e055fc576a9862fbd38ee5e245074b6a9579edef4ec2b9b980dc409f50d7601e43d455a198fa4aee4558247df484eb93cf3147c63f7f71cbc816023271a66820a81c3d229f5b9c4736d4b32c4ddd06980b1dbdd3286cf9c5e1992dfbde90b9771fc9b0eac4721395c80de57c7bcad5a9a2ea898c23fdc6b983fd31b23ecaa999c8792de6a0f64731d7f75abfc4b58856115830dde2f04c515196ccaf621a37145c508f52970e973a0c7ebec78c4dc8ab066e19c3e6f5b0cd30c1da78dc5bf8d0e1cc9d80a8c7ec72b32f92f69bd39013ac2b53684f6745cd0eb76120062d44aede6c0bf7f298c20b716ac854414656028b88745debb6f36f6a5f85bf232c0f5ed79a931d83dd1c39442ddb9829bdb14dff30fd8d2a219fd1f57d519df08b35125f36d49d3d7b3fd026d149639df6dd568971f53268cc5e9b0e646cd8d7faa3c81b85140f3537257e5ac3ac129e3ba1237db13c8fc950e0a6a741593419c85a9a74227fcd6110a74d1b2870b5483970bd74398337170bb16013cdaad9b92b7bee9ba741f3b09deba4229afb1db5b81de971849815f136be66a11c6fee7d494f1805e53a84b02e406c5c885a07454072f4d38d12e9881a71c81f8446fc3aa3f9b5c5b4623cc167b0adb11ea37c68bf84475e456b7037a94b01bad293b66249ed07752c020afaa355d521402a526562d90a75241f8c0d7aa813a82f78a0f12808432d5b75337a0958d854ba313fa31e78a5a395af2376909db3d30a2f52674db534b2acf7880c2da1a9601ae19447362849c6e3b0023abf695c64f08c31bb5f4e82d702455ced041c0c4dae11ca99a221f7a945f24de8e714a4eb3a9c76f946a4b6a771257cf3cfb5810d2b6bc6047309f576ad20b4c6ebcc988fa6e32db4419e7ec653690389e240ae6f4433584ac1a721336672f42654d504ecbce3bf3e7d5a929c3e6cdb2e4b446a3f9a29476d107a1f8f21898ef2ab723005ce9e00d436d7d2a172af11240292f2e19205e16332a851fbda06d02c15af92ceb08282b55a60dbdce90677e58c99538aac559068a637433cf31064c9c3dd0e640e4f88a5a5504fd52d7d36acd86dacb4f022eaa21b8a9753ff4175e9f1caf1791c5b19f6fb5241d403a551a959cbacda8c9c2a480beaeb0a77a59e8a3d5723f786f94d71957171ff8b726ce6ab2c7c939eb12837a34364c206400294afa8a62115a85f45e8254befff8673fed22bede560c0184016870028005324dca26b50ca311134a93ac3bb9dd4cbf2e9aa816baf9f4455885514a452e3d006e6461894e4e895ab3414bb9aff7a0b5cb187ebd7bfc2606795c33b107b54fe40160df67c8c1f4c0d2b7bc9953cd2c5e163ac8df4d9747d83ba42db32687401361db6e5008e85569e2403d4b564ab07ba11b00d6e8ffc759291f0f3f069a6824043dc3d7ea40653b5ec6714518a0be755381c1bae85767abd118aa236caa48ce39bf038046887836b8d28b34367e4e812d2b57b0e703bb5615dbafa1883dfd45e216cc0a7a08bddfc704ce57c89369f8f8fb5cd7f42a4b586231f5c6e630f9fb730bd8837649d4e1110d26ca56bebfb982cabcec2e00d5c21c004a7b50328ade99255c0f88eff971d48e579b2e2d5e68bddb2b73db193ac7b465abfd667ef4da83b5cb6397101a9bfa0be88179c80057086634812cfd21b73b43d25dc96ea380e05e88b86bc0a79b5c5b8c55b0cb7c690c326475e49e3c79936f3f4f15b8c20b63a3ed1c1d8da338caf0d2bcb70f4597d4d0b0e8bcd6ab5f4bfd484b759dfef72bad40c71630f73fa93d3268c8787f7f52add1d6afc60f3b8699def0a57e175f338331e3db91813cfe335989ac8870c2de0a3475b9e13f4f85cddf4bc06c2b0d6f071b6770d8e33ae38c08560da1393bc43130a0e528684f7280895927600d73888cf6c2a314e6d532a486b07b526a8664f8882ac6c8ab9622bb963b3b525790204de40a71a13478aeb20d5491fb835fd6c18627fdac36cd5f18dca334760eb80572d6f27311ee1a6d92ff86b8080b056dbaa94d4ba6838acdc25ccea1a8d582910a8998f6df7add2fb48c88e28f9e8ae9e8ddfe9bd6f045370e5d1f3677c98ba99c31a0dc9d5df17c514a6078e1b1811a579ba35b9089cf00f8690d2e3d90fc470faa946fffc36574da8f57f69eb7527653a9d6c356c18207bf5497ba06e29927d919e26b11e1fbfa93c730ee25e20917fbc5bcbc10f7e5aae129dd651cf0d3e6eb4d7cd964c87b34ea0289209db1a850491189673d6a48712578cda0b61842b426a459512f7a7acf61989124095e2c810124ce310a2ed8b7fd8cf897c756566352a03504f0d7c55c78ee6c9957e56019b188e4e93a0c524c0633b6717ee912bba69960a5ed7035854560b5f52f4ee1cc490340777506d4ad8730f49960b1cfb90f96ac5755c0840ac141246800a2ee37f59a5a984173884b796df554e842d6fe087419ca0e3f9dafcc12ef768ada4a6ad8eee8c4418a3c628edced7ba7c2eb8ed59695531cf2a119334a78de6b9ae6393e1d2d6b2132240571c5b3855ad8ccb773b4e590b70fd08236da9cfb5095c1adc037ef8c7987648d205ea70c3b54aea373678026ab8abb874082bdc88375861ca76a2483f0b00a036e1bd4846909ad64e4145093500d857709bf680ab3c497b8f776ab7a1df5d0eaf783f4f4ee666250f0c1e7c205326c2aa1f7e25668f8ebe095ffa56a98220234ac422ae9a78300fd1e3ecc3d3e84920df5b2f463dd6f47ca514a02edaf29b9c40272af0e922bde18333debe41b2385055b3f9de22dbf9b5aedaf1e69fa3b995109a1cf65f36a7f6eee8e3ef652ea3646e4e4df134880c6d50dee3e2f8df69bb9f7cab8e80e6927d77f9fbd6953bfd44281c6d021969688d7b6a5638e30d7f457f4e5a933f62ee53d3ed4fbecaf979ee186aae1c02dceb48b8df2c78c2e687aff1d21586cd98a05f68342841c1698e1d2c48a384da0e3fde1ec0e01a02387688c6dfd5156958c1a8d5ff9c121732e1658d8a1626109f7b3030e5f19661ab6ccb4704add3f40eea223c1c5ad12d60252812d08eb0fc6170a6ddcabb48b534396fe9ce42e892b3b47a91f120e1b5e1d3fd1e20e8daab806db3c7db142dc88bef136468643812aacd4c5cef46f4f5f2833e533425f8d25af6b3f05e1ffbe92c6daa8e82294af9d9c51f870f50228585ad5fccd535e1b86505364a2d526924fd09a91f8c4a1d9e0e8db00b6e23d394da91fbee4c3849706f66505984222fb9debb1815f985555c01efa0126c788a8ed8dd6b40be507fa801654bcb42393f4f42c8efffb12f1f9cfcd5b4049508c7514285fa8da8c07b33473247b65c66f7a8095a6b276fe6ad8765cc2050a8b4a486190750bbb42541c69e935106818b9ed508a7bfa812c65102355b17b58808269e419552104af198bd4bb0810029238bab1b2b74e10f0fd7ba4a8fc22837c93f0ea907267bb695b719c8</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">夏天是什么时候开始的?</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>发疯随笔</category>
      </categories>
      <tags>
        <tag>精神病发作</tag>
      </tags>
  </entry>
  <entry>
    <title>Manacher算法详解</title>
    <url>/2021/02/12/Manacher-md/</url>
    <content><![CDATA[<p>感谢此篇博文的讲解。<a href="https://wmathor.com/index.php/archives/954/">https://wmathor.com/index.php/archives/954/</a></p>
<a id="more"></a>

<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>给一个字符串 str，要求用 O (n) 的时间复杂度求出其中最长回文子串</p>
<h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><h2 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h2><p>求最大回文子串的长度一般要看原串的长度是奇数还是偶数，然后分别求得。<br>但 Manacher 算法的第一个神奇之处就是把两种字符串都化为长度为奇数，从而简化计算:</p>
<pre><code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">genManacherStr</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">manacher</span><span class="params">(str.size() * <span class="number">2</span> + <span class="number">1</span>, <span class="string">&#x27;#&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; manacher.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &amp; <span class="number">1</span>)   manacher[i] = str[i/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; manacher &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> manacher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p><strong>也就是将每个字符的间隔间插入一个’#’字符(或其他不会出现的字符都可以)</strong> 。这样就将原字符串长度变成奇数, 并且使以每个原字符为中心的都是对称的。如原来是aba，变化之后就是 #a#b#a#，无论原来是奇数还是偶数，变化之后都是奇数，方便处理。</p>
<h2 id="三个重要概念"><a href="#三个重要概念" class="headerlink" title="三个重要概念"></a>三个重要概念</h2><ol>
<li>回文右边界下标R。</li>
<li>回文中心C。</li>
<li>记录每个字符的回文半径长度数组helper。</li>
</ol>
<h3 id="回文右边界下标R"><a href="#回文右边界下标R" class="headerlink" title="回文右边界下标R"></a>回文右边界下标R</h3><p>指的是当前构成回文半径时, 此回文字符串的最右边的下标索引。<br>如#a#b#a#, 当遍历到第一个’a’时, 下标索引是1， 回文右边界下标将达到’a’右侧的’#’, 下标R为2, 回文半径长度为(2-1)+1=2。</p>
<h3 id="回文中心C"><a href="#回文中心C" class="headerlink" title="回文中心C"></a>回文中心C</h3><p><strong>达到回文最右边界下标R时</strong>的对称中心C, 如上述例子的遍历到第一个’a’时的下标1, 就是当前的回文中心C。</p>
<h3 id="记录每个字符的回文半径数组helper"><a href="#记录每个字符的回文半径数组helper" class="headerlink" title="记录每个字符的回文半径数组helper"></a>记录每个字符的回文半径数组helper</h3><p>每个字符所对应的最大半径, 如上述例子的第一个’a’, 半径就是2。</p>
<h2 id="如何确定回文半径"><a href="#如何确定回文半径" class="headerlink" title="如何确定回文半径"></a>如何确定回文半径</h2><p><strong>首先, 我们需要初始化最右回文边界下标为-1, 回文中心的下标为-1。</strong></p>
<p>接着我们需要分2种大情况来讨论:</p>
<ul>
<li>当前判断的下标索引i大于等于回文右边界的下标R。</li>
<li>当前判断的下标索引i小于最右回文右边界的下标R。</li>
</ul>
<h3 id="情形一-i-gt-R"><a href="#情形一-i-gt-R" class="headerlink" title="情形一: i &gt;= R"></a>情形一: i &gt;= R</h3><p><img src="/2021/02/12/Manacher-md/manacher1.png" alt="情形一: i &gt;= R"></p>
<p>此时我们没法得知i的右边是否和i的左边构成回文字符串, 只能暴力扩展。<br><strong>(图中是i &gt; R下标的情况, 实际上从i == R的时候就开始要暴力扩展了)。</strong></p>
<h3 id="情形二-i-lt-R"><a href="#情形二-i-lt-R" class="headerlink" title="情形二: i &lt; R"></a>情形二: i &lt; R</h3><p>这是问题的关键, 假如我们已经求出了helper[0,1,2,…,i-1], 现在要求出i的回文半径。分以下三种情况:</p>
<h4 id="i的对称点i’的左边界超过了回文左边界"><a href="#i的对称点i’的左边界超过了回文左边界" class="headerlink" title="i的对称点i’的左边界超过了回文左边界"></a>i的对称点i’的左边界超过了回文左边界</h4><p>回文左边界就是回文右边界关于C的对称坐标，定义一样。如图:</p>
<p><img src="/2021/02/12/Manacher-md/manacher2.png" alt="i&#39;左边界超过了回文左边界"></p>
<p><strong>这个情况直接可以断定i的回文右边界和R重合。</strong> 证明如下:</p>
<ul>
<li>如图，i到R之间的字符串为S, 那么关于C对称，可以得到R’到i’之间的字符串为S’。</li>
<li>又因为R’到i’之间的S’关于i’对称, 所以可以得到对称的字符串S在i’的左侧处。</li>
<li>而i’左侧的S又关于C的对称，正好会落于i的左侧部分。所以i的回文半径字符串<strong>至少为S.</strong></li>
</ul>
<p><strong>上述证明了i的回文半径字符串为S, 那如何证明只能为S呢？</strong></p>
<p>已知i’的最左边界超过了R’，那么表示超过的部分不关于C的对称。<br>也就是说，i右侧的字符串S如果向外扩展，它与R’的左侧是不对称的。所以得证，只能为S。</p>
<h4 id="i的对称点i’的左边界小于R’"><a href="#i的对称点i’的左边界小于R’" class="headerlink" title="i的对称点i’的左边界小于R’"></a>i的对称点i’的左边界小于R’</h4><p><img src="/2021/02/12/Manacher-md/manacher3.png" alt="i&#39;左边界在回文左边界内"></p>
<p>还是用S字符串来证明。这种情况就比较简单。和上述证明方式一样，S不可能外扩，必将和i’的回文字符串一致，<strong>所以为helper[i’].</strong></p>
<h4 id="i的对称点i’的左边界正好和R’重合"><a href="#i的对称点i’的左边界正好和R’重合" class="headerlink" title="i的对称点i’的左边界正好和R’重合"></a>i的对称点i’的左边界正好和R’重合</h4><p><img src="/2021/02/12/Manacher-md/manacher4.png" alt="i&#39;左边界与R&#39;重合"></p>
<p>显而易见, 还是要暴力往外扩。</p>
<h3 id="两种情况下的部分代码建模"><a href="#两种情况下的部分代码建模" class="headerlink" title="两种情况下的部分代码建模"></a>两种情况下的部分代码建模</h3><p>综上分析，</p>
<ul>
<li>当i在R的右边界外时，回文半径应该初始化为1，然后去暴力扩展，左右相同时半径+1.</li>
<li>当i在R的右边界内时，看i’的左边界:<ul>
<li>情况a: i’左边界超出回文半径左边界，那么回文半径应该初始化为<strong>R-i</strong>, 即上述字符串S的长度。</li>
<li>情况b: i’左边界在回文半径左边界内, 那么回文半径应该初始化为helper[i’], i’下标为C-(i-C) = 2 * C - i, 所以为helper[2 * C - i]。</li>
<li>情况c: i’左边界与回文半径左边界重合, 那么回文半径应该初始化为helper[i’], 然后再暴力扩展。</li>
</ul>
</li>
</ul>
<p>所以当R &gt; i 时, 回文半径可以初始化为min(R-i, helper[2 * C - i]), 然后再去暴力扩展。<br>这么写的话，碰到情况a, 那么小的值就是R-i, 暴力扩展第一次就会发现不匹配。<br>碰到情况b, 小的值就是helper[i’], 暴力扩展第一次也会发现不匹配。<br>碰到情况c, helper[i’]和R-i是相等的，暴力扩展到第一次出现不匹配为止，当然，每成功匹配一次需要+1。</p>
<p>当i&gt;=R时，就应该初始化半径为1，再去暴力扩展。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.size() &lt; <span class="number">2</span>)    <span class="keyword">return</span> s;</span><br><span class="line">    <span class="built_in">string</span> manacher = genManacherStr(s);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">helper</span><span class="params">(manacher.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> R = <span class="number">-1</span>, C = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; manacher.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根据i是否在R里面来讨论</span></span><br><span class="line">        helper[i] = R &gt; i ? min(R-i, helper[<span class="number">2</span>*C-i]) : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i+helper[i] &lt; manacher.size() &amp;&amp; i-helper[i] &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(manacher[i+helper[i]] == manacher[i-helper[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                helper[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新回文最右边界的下标R和回文中心C</span></span><br><span class="line">        <span class="keyword">if</span>(i+helper[i] &gt; R)</span><br><span class="line">        &#123;</span><br><span class="line">            R = i + helper[i];</span><br><span class="line">            C = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若回文半径变长，需要算出原字符串的起始索引start</span></span><br><span class="line">        <span class="keyword">if</span>(helper[i] &gt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            len = helper[i];</span><br><span class="line">            <span class="comment">// 这一步真尼玛难算啊！先算出加了#的manacher字符串中，回文字符串的最左边界应该是i-(len-1) = i-len+1。</span></span><br><span class="line">            <span class="comment">// 如#a#b#a#, b为回文中心时, i为3, len的值为4，即最长回文半径的值为4，回文最左边界就是3-(4-1)=0.</span></span><br><span class="line">            <span class="comment">// 由于添加了#字符,所以回文串总以#为起始和结尾，所以i-len+1这个下标对应的一定是#.</span></span><br><span class="line">            <span class="comment">// 所以最左边#的右边一个字符，就是原字符串的回文最左侧, 即i-len+2;</span></span><br><span class="line">            <span class="comment">// 那么, 对应原字符串的下标为(i-len+2)/2, 可得start=(i-len+2)/2;</span></span><br><span class="line">            start = (i-len+<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长度为len-1，因为对称中心只有1个字符，不能算2遍。</span></span><br><span class="line">    <span class="comment">// 所以加了#的Manacher字符串的回文半径-1就等于原字符串的回文直径长度。</span></span><br><span class="line">    <span class="keyword">return</span> s.substr(start, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
</search>
